#include "stdafx.h"
#include "ENWFactory.h"
#include <time.h>
#include <base64.h>
#include <rsa.h>
#include <files.h>
#include <aes.h>
#include <modes.h>
#include <eax.h>
#include <hex.h>
#include <windows.h>
#include <tchar.h>
#include "CPU.h"

CryptoFactory::CryptoFactory() {}
CryptoFactory::~CryptoFactory() {}

void CryptoFactory::V1_MyEncryptFile(CryptoPP::SecByteBlock& key, CryptoPP::SecByteBlock& iv,
	std::string publickeyfile, std::string filetoencrypt, std::string encryptedfile)
{
	try {
		std::string data;
		CryptoPP::EAX<CryptoPP::AES>::Encryption aesEncryption;
		aesEncryption.SetKeyWithIV(key, key.size(), iv, iv.size());
#ifdef BG_CONCURRENCY
		if (!SetThreadPriority(GetCurrentThread(), THREAD_MODE_BACKGROUND_BEGIN))
		{
			DWORD dwError = GetLastError();
			if (ERROR_THREAD_MODE_ALREADY_BACKGROUND == dwError)
				_tprintf(TEXT("Already in background mode\n"));
			else _tprintf(TEXT("Failed to enter background mode (%d)\n"), dwError);
			exit(EXIT_FAILURE);
		}
#endif
		CryptoPP::FileSource f(filetoencrypt.c_str(), true,
			new CryptoPP::AuthenticatedEncryptionFilter(aesEncryption,
				new CryptoPP::FileSink(encryptedfile.c_str())));
#ifdef BG_CONCURRENCY
		if (!SetThreadPriority(GetCurrentThread(), THREAD_MODE_BACKGROUND_END))
		{
			_tprintf(TEXT("Failed to end background mode (%d)\n"), GetLastError());
		}
#endif
	}
	catch (CryptoPP::Exception& e) {
		std::cout << "EncryptFile: " << e.what() << std::endl;
	}
}

void CryptoFactory::V1_MyDecryptFile(CryptoPP::SecByteBlock& key, CryptoPP::SecByteBlock& iv,
	std::string pvtFilename, std::string cipheredFile, std::string restoreFile)
{
	try {
		CryptoPP::EAX<CryptoPP::AES>::Decryption decryptor;
		decryptor.SetKeyWithIV(key, key.size(), iv, iv.size());

		CryptoPP::FileSource fss(cipheredFile.data(), true,
			new CryptoPP::AuthenticatedDecryptionFilter(decryptor,
				new CryptoPP::FileSink(restoreFile.c_str())));
	}
	catch (CryptoPP::Exception& e) {
		std::cout << "DecryptFile: " << e.what() << std::endl;
	}
}

#undef BG_CONCURRENCY

void CryptoFactory::V2_MyEncryptFile(CryptoPP::SecByteBlock &key, std::string filetoencrypt, std::string encryptedfile)
{
	std::ifstream ifs(filetoencrypt);
	if (ifs.is_open()) {
		try {

			CryptoPP::SecByteBlock iv(CryptoPP::AES::BLOCKSIZE);
			CryptoPP::RandomNumberSource randomsrc(rng, CryptoPP::AES::BLOCKSIZE, new CryptoPP::ArraySink(iv, iv.size()));

			CryptoPP::EAX<CryptoPP::AES>::Encryption encryptor;
			encryptor.SetKeyWithIV(key, key.size(), iv, iv.size());

			CryptoPP::FileSink targetFile(encryptedfile.c_str());
			CryptoPP::ArraySource as(iv, iv.size(), true,
				new CryptoPP::Redirector(targetFile));

#ifdef BG_CONCURRENCY
			if (!SetThreadPriority(GetCurrentThread(), THREAD_MODE_BACKGROUND_BEGIN))
			{
				DWORD dwError = GetLastError();
				if (ERROR_THREAD_MODE_ALREADY_BACKGROUND == dwError)
					_tprintf(TEXT("Already in background mode\n"));
				else _tprintf(TEXT("Failed to enter background mode (%d)\n"), dwError);
				exit(EXIT_FAILURE);
			}
#endif

			CryptoPP::FileSource ss(filetoencrypt.c_str(), true,
				new CryptoPP::AuthenticatedEncryptionFilter(encryptor,
					new CryptoPP::Redirector(targetFile)));
	
#ifdef BG_CONCURRENCY
			if (!SetThreadPriority(GetCurrentThread(), THREAD_MODE_BACKGROUND_END))
			{
				_tprintf(TEXT("Failed to end background mode (%d)\n"), GetLastError());
			}
#endif
			std::cout << "Encryption OK\n";
			//std::cout << "Encryption completed for " << filetoencrypt << std::endl;
			ifs.close();
		}
		catch (CryptoPP::Exception& e) {
			std::cout << "Error while encrypting file: " << e.what() << std::endl;
		}
	}
}

void CryptoFactory::V2_MyDecryptFile(CryptoPP::SecByteBlock &key, std::string cipheredFile, std::string restoreFile)
{
	std::ifstream ifs(cipheredFile);
	if (ifs.is_open()) {
		if (pathExtFinder(cipheredFile, ".vogu")) {
			try {
				CryptoPP::SecByteBlock iv(CryptoPP::AES::BLOCKSIZE);
				CryptoPP::FileSource fs(cipheredFile.c_str(), false);

				CryptoPP::ArraySink as(iv, iv.size());
				fs.Attach(new CryptoPP::Redirector(as));
				fs.Pump(CryptoPP::AES::BLOCKSIZE);


				CryptoPP::EAX<CryptoPP::AES>::Decryption decryptor;
				decryptor.SetKeyWithIV(key, key.size(), iv, iv.size());

				CryptoPP::ByteQueue bq;
				fs.Detach(new CryptoPP::AuthenticatedDecryptionFilter(decryptor, new CryptoPP::Redirector(bq)));
				fs.PumpAll();

				CryptoPP::FileSink sink(restoreFile.c_str());
				bq.TransferTo(sink);
				std::cout << "Decryption OK\n";
			}
			catch (CryptoPP::Exception& e) {
				std::cout << "Error while decrypting file: " << e.what() << std::endl;
			}
		}
	}
}
void CryptoFactory::V3_MyEncryptFile(std::string filetoencrypt, std::string encryptedfile)
{
	std::ifstream ifs(filetoencrypt);
	if (ifs.is_open()) {
		try {

			CryptoPP::SecByteBlock iv(CryptoPP::AES::BLOCKSIZE), key(CryptoPP::AES::MAX_KEYLENGTH);
			CryptoPP::RandomNumberSource randomsrc(rng, CryptoPP::AES::BLOCKSIZE, new CryptoPP::ArraySink(iv, iv.size()));
			CryptoPP::RandomNumberSource randomsrcaes(rng, CryptoPP::AES::MAX_KEYLENGTH, new CryptoPP::ArraySink(key, key.size()));

			CryptoPP::EAX<CryptoPP::AES>::Encryption encryptor;
			encryptor.SetKeyWithIV(key, key.size(), iv, iv.size());

			CryptoPP::FileSink targetFile(encryptedfile.c_str());
			CryptoPP::ArraySource as(iv, iv.size(), true,
				new CryptoPP::Redirector(targetFile));
			CryptoPP::ArraySource asaes(key, key.size(), true,
				new CryptoPP::Redirector(targetFile));

#ifdef BG_CONCURRENCY
			if (!SetThreadPriority(GetCurrentThread(), THREAD_MODE_BACKGROUND_BEGIN))
			{
				DWORD dwError = GetLastError();
				if (ERROR_THREAD_MODE_ALREADY_BACKGROUND == dwError)
					_tprintf(TEXT("Already in background mode\n"));
				else _tprintf(TEXT("Failed to enter background mode (%d)\n"), dwError);
				exit(EXIT_FAILURE);
			}
#endif

			CryptoPP::FileSource ss(filetoencrypt.c_str(), true,
				new CryptoPP::AuthenticatedEncryptionFilter(encryptor,
					new CryptoPP::Redirector(targetFile)));

#ifdef BG_CONCURRENCY
			if (!SetThreadPriority(GetCurrentThread(), THREAD_MODE_BACKGROUND_END))
			{
				_tprintf(TEXT("Failed to end background mode (%d)\n"), GetLastError());
			}
#endif
			std::cout << "Encryption OK\n";
			ifs.close();
		}
		catch (CryptoPP::Exception& e) {
			std::cout << "Error while encrypting file: " << e.what() << std::endl;
		}
	}
}

void CryptoFactory::V3_MyDecryptFile(std::string cipheredFile, std::string restoreFile)
{
	std::ifstream ifs(cipheredFile);
	if (ifs.is_open()) {
		if (pathExtFinder(cipheredFile, ".vogu")) {
			try {
				CryptoPP::SecByteBlock iv(CryptoPP::AES::BLOCKSIZE), key(CryptoPP::AES::MAX_KEYLENGTH);
				CryptoPP::FileSource fs(cipheredFile.c_str(), false);

				CryptoPP::ArraySink as(iv, iv.size());
				fs.Attach(new CryptoPP::Redirector(as));
				fs.Pump(CryptoPP::AES::BLOCKSIZE);

				CryptoPP::ArraySink asaes(key, key.size());
				fs.Attach(new CryptoPP::Redirector(asaes));
				fs.Pump(CryptoPP::AES::MAX_KEYLENGTH);


				CryptoPP::EAX<CryptoPP::AES>::Decryption decryptor;
				decryptor.SetKeyWithIV(key, key.size(), iv, iv.size());

				CryptoPP::ByteQueue bq;
				fs.Detach(new CryptoPP::AuthenticatedDecryptionFilter(decryptor, new CryptoPP::Redirector(bq)));
				fs.PumpAll();

				CryptoPP::FileSink sink(restoreFile.c_str());
				bq.TransferTo(sink);
				std::cout << "Decryption OK\n";
				//				std::cout << "Decryption completed for " << cipheredFile << std::endl;
			}
			catch (CryptoPP::Exception& e) {
				std::cout << "Error while decrypting file: " << e.what() << std::endl;
			}
		}
	}
}


void CryptoFactory::GenerateRSAKeyPair(std::string privFilename, std::string pubFilename)
{
	CryptoPP::InvertibleRSAFunction privKey;
	privKey.Initialize(rng, 2048);

	CryptoPP::Base64Encoder privSink(new CryptoPP::FileSink(privFilename.c_str()));
	privKey.DEREncode(privSink);
	privSink.MessageEnd();

	CryptoPP::RSAFunction pubKey(privKey);
	CryptoPP::Base64Encoder pubSink(new CryptoPP::FileSink(pubFilename.c_str()));
	pubKey.DEREncode(pubSink);
	pubSink.MessageEnd();
}

std::string CryptoFactory::RSAESEncryption(std::string pubkeyfile, CryptoPP::SecByteBlock& key)
{
	CryptoPP::FileSource pubFile(pubkeyfile.c_str(), true, new CryptoPP::Base64Decoder);
	CryptoPP::RSAES_OAEP_SHA_Encryptor encryptor(pubFile);

	std::string sessionkey;
	CryptoPP::ArraySource as(key, true,
		new CryptoPP::PK_EncryptorFilter(
			rng,
			encryptor,
			new CryptoPP::Base64Encoder(new CryptoPP::StringSink(sessionkey))));
	return sessionkey;
}

std::string CryptoFactory::RSAESDecryption(std::string pvtkeyfile, const char* sessionkey)
{
	CryptoPP::FileSource privFile(pvtkeyfile.c_str(), true, new CryptoPP::Base64Decoder);
	CryptoPP::RSAES_OAEP_SHA_Decryptor decryptor(privFile);

	std::string result;
	CryptoPP::StringSource(sessionkey, true,
		new CryptoPP::Base64Decoder(
			new CryptoPP::PK_DecryptorFilter(rng,
				decryptor,
				new CryptoPP::StringSink(result))));
	return result;
}

void CryptoFactory::SignAESKey(std::string privFilename, std::string AESKeyFileName,
	std::string signatureFilename)
{
	try{
		CryptoPP::ByteQueue bytes;
		CryptoPP::FileSource file(privFilename.c_str(), true, new CryptoPP::Base64Decoder);
		file.TransferTo(bytes);
		bytes.MessageEnd();

		CryptoPP::RSA::PrivateKey privateKey;
		privateKey.Load(bytes);

		CryptoPP::RSASSA_PKCS1v15_SHA_Signer privkey(privateKey);
		CryptoPP::SecByteBlock sbbSignature(privkey.SignatureLength());

		privkey.SignMessage(
			rng,
			(CryptoPP::byte const*)AESKeyFileName.data(),
			AESKeyFileName.size(),
			sbbSignature);


	}
	catch (CryptoPP::Exception& e) {
		std::cout << e.what() << std::endl;
	}
}


bool CryptoFactory::VerifyAESKey(std::string pubFilename, std::string AESKeyFileName,
	std::string signatureFilename)
{
	try {
		CryptoPP::FileSource pubFile(pubFilename.c_str(), true, new CryptoPP::Base64Decoder);
		CryptoPP::RSASSA_PKCS1v15_SHA_Verifier pub(pubFile);

		CryptoPP::FileSource signatureFile(signatureFilename.c_str(), true,
			new CryptoPP::Base64Decoder);
		if (signatureFile.MaxRetrievable() != pub.SignatureLength())
			return false;
		CryptoPP::SecByteBlock signature(pub.SignatureLength());
		signatureFile.Get(signature, signature.size());

		CryptoPP::SignatureVerificationFilter *verifierFilter = new CryptoPP::SignatureVerificationFilter(pub);
		verifierFilter->Put(signature, pub.SignatureLength());
		CryptoPP::FileSource f(AESKeyFileName.c_str(), true, verifierFilter);

		return verifierFilter->GetLastResult();
	}
	catch (CryptoPP::Exception& e) {
		std::cout << e.what() << std::endl;
	}
 }

bool CryptoFactory::pathExtFinder(std::string const & A, std::string const & B)
{
	return A.length() >= B.length()
		? (0 == A.compare(A.length() - B.length(), B.length(), B))
		: false;
}
